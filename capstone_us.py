# -*- coding: utf-8 -*-
"""Capstone US

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bn_PUit7p5oYO3QL8GrMYc_bZmD9eY46
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns

url = "https://docs.google.com/spreadsheets/d/1ibug5mfJXtIUAg5YjrYzI4Ow834Twnet9tmxMGtV9Qo/export?format=csv"
project = pd.read_csv(url)
project.head()

project.info()

project['Date'].unique()

url = "https://docs.google.com/spreadsheets/d/1lF7sCzwERC-K1TNOD3ALYGUR5oX1IPfEBjoDZtSBaJI/export?format=csv"
full_group = pd.read_csv(url)
full_group.head()

full_group ['Country/Region'].unique()

us_data = full_group[full_group['Country/Region'] == 'US']
us_data.head()

us_data['Date'].unique().max()

us_data.info()

# Convert 'Date' to datetime objects for proper comparison if they are not already
project['Date'] = pd.to_datetime(project['Date'])
us_data['Date'] = pd.to_datetime(us_data['Date'])

# Merge the datasets using 'Date' as the common column
merged_data = pd.merge(project, us_data, on='Date', how='inner')

# Display the merged data
merged_data.head()

merged_data.info()

covid_data = merged_data.drop(columns=['UID', 'Country_Region', 'Country/Region', 'iso2', 'iso3', 'code3', 'FIPS', 'Admin2', 'Lat', 'Long_', 'Combined_Key', 'WHO Region', 'Confirmed_x', 'Deaths_x'])
covid_data.head()

covid_data.columns



plt.figure(figsize=(12, 6))
plt.plot(covid_data['Date'], covid_data['Confirmed_y'], label='Confirmed Cases')
plt.plot(covid_data['Date'], covid_data['Deaths_y'], label='Deaths')
plt.plot(covid_data['Date'], covid_data['Recovered'], label='Recovered')
plt.xlabel('Date')
plt.ylabel('Number of Cases')
plt.title('COVID-19 Cases Over Time in the US')
plt.legend()
plt.grid(True)
plt.savefig(f'covid_cases_over_time.png')
plt.show()

state_cases = covid_data.groupby('Province_State')['Confirmed_y'].sum().sort_values(ascending=False)
plt.figure(figsize=(12, 6))
sns.barplot(x=state_cases.index, y=state_cases.values, palette = 'viridis')
plt.xlabel('State')
plt.ylabel('Total Confirmed Cases')
plt.title('Total Confirmed Cases by State')
plt.xticks(rotation=90)
plt.savefig(f'Total_confirmed_cases_by_state.png')
plt.show()

state_cases = covid_data.groupby('Province_State')['Deaths_y'].sum().sort_values(ascending=False)
plt.figure(figsize=(12, 6))
sns.barplot(x=state_cases.index, y=state_cases.values, palette = 'viridis')
plt.xlabel('State')
plt.ylabel('Total Death Cases')
plt.title('Total Death Cases by State')
plt.xticks(rotation=90)
plt.savefig(f'Total_death_cases_by_state.png')
plt.show()

state_cases = covid_data.groupby('Province_State')['Recovered'].sum().sort_values(ascending=False)
plt.figure(figsize=(12, 6))
sns.barplot(x=state_cases.index, y=state_cases.values, palette = 'viridis')
plt.xlabel('State')
plt.ylabel('Total Recovered Cases')
plt.title('Total Recovered Cases by State')
plt.xticks(rotation=90)
plt.savefig(f'Total_recovered_cases_by_state.png')
plt.show()

state_cases = covid_data.groupby('Province_State')['Active'].sum().sort_values(ascending=False)
plt.figure(figsize=(12, 6))
sns.barplot(x=state_cases.index, y=state_cases.values, palette = 'viridis')
plt.xlabel('State')
plt.ylabel('Total Active Cases')
plt.title('Total Active Cases by State')
plt.xticks(rotation=90)
plt.savefig(f'Total_active_cases_by_state.png')
plt.show()

covid_data.head()

covid_corr = covid_data.drop(columns=['Province_State', 'Date'])
covid_corr.corr()

sns.heatmap(covid_corr.corr(), annot=True, cmap = 'coolwarm')
plt.title('Correlation Heatmap')
plt.savefig(f'correlation_heatmap.png')
plt.show()

sns.regplot(data = covid_corr.corr(), x = 'Confirmed_y', y = 'Deaths_y')
plt.title('Correlation between Deaths and Confirmed Cases')
plt.savefig(f'correlation_between_deaths_and_confirmed_cases.png')
plt.show()

sns.regplot(data = covid_corr.corr(), x = 'Confirmed_y', y = 'Recovered')
plt.title('Correlation between Recovered and Confirmed Cases')
plt.savefig(f'correlation_between_recovered_and_confirmed_cases.png')
plt.show()

sns.regplot(data = covid_corr.corr(), x = 'Confirmed_y', y = 'Active')
plt.title('Correlation between Active and Confirmed Cases')
plt.savefig(f'correlation_between_active_and_confirmed_cases.png')
plt.show()

sns.regplot(data = covid_corr.corr(), x = 'New cases', y = 'New deaths')
plt.title('Correlation between New Cases and New Death Cases')
plt.savefig(f'correlation_between_new_cases_and_new_death_cases.png')
plt.show()

sns.regplot(data = covid_corr.corr(), x = 'New cases', y = 'New recovered')
plt.title('Correlation between New Cases and New Recovered Cases')
plt.savefig(f'correlation_between_new_cases_and_new_recovered_cases.png')
plt.show()

#Feature Engineering
covid_data['Growth_rate'] = covid_data['Confirmed_y'].pct_change() * 100
covid_data['Mortality_rate'] = (covid_data['Deaths_y']/ covid_data['Confirmed_y']) * 100
covid_data['Recovery_rate'] = (covid_data['Recovered']/ covid_data['Confirmed_y']) * 100
covid_data['Active_case_ratio'] = (covid_data['Active']/ covid_data['Confirmed_y']) * 100

population = 331198130
total_test = 5032179

covid_data['New_case_per_100k'] = (covid_data['New cases']/population) * 100
covid_data['Test_per_confirmed_cases'] = total_test/ (covid_data['Confirmed_y'])
covid_data.head()

covid_data.info()

float64_cols = covid_data.select_dtypes(include=['float64']).columns
covid_data[float64_cols] = covid_data[float64_cols].replace([np.inf, -np.inf], np.nan).fillna(0)
covid_data[float64_cols] = covid_data[float64_cols].astype(int)
covid_data.info()

#Predictive modelling
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score, root_mean_squared_error

x = covid_data.drop(columns = ['Province_State', 'Date', 'Active'], axis = 1)
y = covid_data['Active']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 42)
regr = LinearRegression()
regr.fit(x_train, y_train)
pred = regr.predict(x_test)

#Model Evaluation
mse = mean_squared_error(y_test, pred)
r2 = r2_score(y_test, pred)
rmse = root_mean_squared_error(y_test, pred)
print(f'Mean Squared Error: {mse}')
print(f'R-squared: {r2}')
print(f'Root Mean Squared Error: {rmse}')

#Prediction with Decision Tree Regressor Algorithm
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import accuracy_score

model = DecisionTreeRegressor()
model.fit(x_train, y_train)
pred_tree = model.predict(x_test)


score = model.score(x_test, y_test)
Mse = mean_squared_error(y_test, pred_tree)
R2 = r2_score(y_test, pred_tree)
Rmse = root_mean_squared_error(y_test, pred_tree)


print(f'Mean Squared Error: {Mse}')
print(f'R-squared: {R2}')
print(f'Root Mean Squared Error: {Rmse}')
print(f'Accuracy: {score}')

from sklearn.ensemble import RandomForestRegressor

# Create a Random Forest Regressor object
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)  # You can adjust hyperparameters

# Train the model
rf_model.fit(x_train, y_train)

# Make predictions
rf_predictions = rf_model.predict(x_test)

# Evaluate the model
mse = mean_squared_error(y_test, rf_predictions)
r2 = r2_score(y_test, rf_predictions)
rmse = root_mean_squared_error(y_test, rf_predictions)

print(f'Mean Squared Error: {mse}')
print(f'R-squared: {r2}')
print(f'Root Mean Squared Error: {rmse}')

